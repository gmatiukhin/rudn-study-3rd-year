\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{paracol}
\usepackage[russian]{babel}
\usepackage[14pt]{extsizes} % для того чтобы задать нестандартный 14-ый размер шрифта
\usepackage[left=20mm, top=15mm, right=15mm, bottom=30mm, footskip=15mm]{geometry} % настройки полей документа
\usepackage[utf8]{inputenc}
\usepackage[style=gost-numeric]{biblatex}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\usepackage{minted}

\usepackage{changepage}

%https://tex.stackexchange.com/questions/403463/signature-on-latex-lines
\newcommand\signature{%
   \begin{minipage}[t]{5cm}
   \vspace*{1.5ex}  % leave some space above the horizontal line
   \hrule
   \vspace{1mm} % just a bit more whitespace below the line
   \centering
   \begin{tabular}[t]{c}
   \small{(подпись)}
   \end{tabular}
   \end{minipage}}

\usepackage{xcolor}

\newcommand{\emptydate}{<<\underline{\phantom{99}}>> \underline{\phantom{февралиюня}} \the\year{} г.}

\addbibresource{sources.bib}

\title{Разработка PDDL планировщика}
\author{Матюхин Григорий Васильевич}

\begin{document}

% НАЧАЛО ТИТУЛЬНОГО ЛИСТА
\begin{titlepage}
    \setlength{\parindent}{0cm}
    
    \begin{center}
    \hfill \break 
    \textbf{
    \smallФедеральное государственное автономное образовательное учреждение высшего образования\\
    \normalsize<<РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ\\ имени ПАТРИСА ЛУМУМБЫ>> (РУДН)
    }
    \vspace{1cm}

    \begin{paracol}{2}
      \raggedrightОсновное учебное подразделение
      \switchcolumn
      \underline{факультет физико-математических}
      \underline{и естественных наук}
    \end{paracol}

    \vspace{0.5em}

    \begin{paracol}{2}
      \raggedrightНаправление/специальность
      \switchcolumn
      \underline{09.03.03 <<Прикладная информатика>>}
      \end{paracol}
    \centering
    
    \vspace*{\fill}
    
    \textbf{ОТЧЕТ} \\
    \vspace{1em}
    \textbf{о прохождении учебной практики <<Научно-исследовательская работа\\ (получение первичных навыков научно-исследовательской работы)>>}
    % \\
    % \tiny{(вид и наименование практики)}
    \\ \vspace{5mm}
    \normalsize{\underline{Матюхин Григорий Васильевич}}
    % \\
    % \tiny{(Ф. И. О. обучающегося)}
    \vspace{1em}
    \end{center}
    
    Курс, группа \underline{3, НПИбд-01-21} \\

    Место прохождения практики 
    \underline{<<Отдел технической поддержки пользователей ОТПП}\\
    \underline{департамента технологических и информационных ресурсов РУДН и научные центры}\\
    \underline{института компьютерных наук и телекоммуникаций РУДН>>} \\

    Сроки прохождения с <<15>> апреля 2024 г. по <<15>> июня 2024 г.

    \vspace*{\fill}

    \begin{adjustwidth}{0.4\textwidth}{0pt}
      Руководители практики:\\

      от РУДН \underline{Фомин М.Б., доцент  кафедры ММиИИ}\\

      от организации (предприятия)

      \underline{Самуйлов К.Е., директор ИКНиТ}
       
    \end{adjustwidth}
    \vspace{1em}
    
    Оценка: \underline{\phantom{1234567890 баллов}}

    \vspace*{\fill}
     
    \centering Москва 2024 г.
    \thispagestyle{empty} % выключаем отображение номера для этой страницы
     
\end{titlepage}
% КОНЕЦ ТИТУЛЬНОГО ЛИСТА
    
\newpage

\tableofcontents

\newpage

\section{Введение}

Согласно программе преддипломной практики направления подготовки 09.03.03 <<Прикладная информатика>> целями практики являются:
\begin{itemize}
\item формирование профессиональных навыков в проведении научных исследований;
\item формирование навыков использования современных научных методов для решения научных и практических задач;
\item формирование практических навыков написания вспомогательных программных комплексов для проведения вычислительных экспериментов;
\item формирование общекультурных, общепрофессиональный и профессиональных компетенций в соответствии с ОС ВО РУДН;
\item формирование навыков оформления и представления результатов научного исследования;
\item формирование навыков работы с источниками данных.
\end{itemize}

    Там же определены задачи практики:
\begin{itemize}
\item формирование у студентов навыков в области изучения научной литературы и (или) научно-исследовательских проектов в соответствии с будущим профилем профессиональной деятельности и применения новых научных результатов;
\item обучение правильному составлению научных обзоров и отчетов;
\item формирование навыков решения конкретных научно-практических задач самостоятельно или в научном коллективе;
\item обучение навыкам работы с прикладными комплексами программ для проведения вычислительных экспериментов;
\item формирование способности разработки вспомогательных программных инструментов;
\item обучение подготовке научных публикаций;
\item формирование способности проводить научные исследования и получать новые научные и прикладные результаты.
\end{itemize}

    Для достижения целей и решения поставленных задач в рамках преддипломной практики я выполнил обзор публикаций российских и международных научных изданий по теме выпускной квалификационной работы (ВКР) бакалавра, которая определена как <<Разработка PDDL планировщика>>.

\newpage

\section{Предварительная информация}

\subsection{Планировщики}
Планировщики~\cite{ghallab2004automated} — это системы, используемые для автоматического создания последовательности действий, необходимых для достижения заданной цели в определенной среде. Они широко применяются в различных областях, таких как робототехника, логистика, искусственный интеллект и управление задачами. Основная задача планировщика заключается в нахождении оптимального или приемлемого плана, который переводит систему из начального состояния в целевое состояние, удовлетворяя при этом заданным ограничениям и условиям.

\subsection{PDDL (Planning Domain Definition Language)}

PDDL (Язык Определения Домена Планирования)~\cite{mcdermott1998pddl}~\cite{gerevini2006pddl3} — это стандартный язык для формализации задач планирования. Он был разработан в 1998 году для унификации описаний задач в области планирования и является основным языком, используемым в конкурсах по автоматическому планированию. PDDL позволяет описывать как статические аспекты (объекты и их свойства), так и динамические аспекты (действия и их последствия) планируемой среды.

Основные компоненты PDDL включают:
\begin{enumerate}
  \item Домен: Описание возможных действий и предикатов, которые могут использоваться в планируемой среде. Домен включает определения типов объектов, предикатов (свойств и отношений) и операторов (действий).
  \item Проблема: Конкретизация задачи планирования, в которой указаны объекты, начальное состояние и целевое состояние. Проблема определяет, какие из предикатов и операторов из домена используются в данной конкретной задаче.
\end{enumerate}

\subsubsection{Структура PDDL}

PDDL файлы обычно разделены на два файла: файл домена и файл задачи.

\begin{enumerate}
\item Файл домена:
  \begin{minted}{lisp}
   (define (domain blocks-world)
     (:predicates (on ?x ?y) (clear ?x) (table ?x))
     (:action move
       :parameters (?x ?y ?z)
       :precondition (and (clear ?x) (clear ?z) (on ?x ?y))
       :effect (and
         (not (on ?x ?y)) (on ?x ?z) (clear ?y) (not (clear ?z)))))
  \end{minted}

\item Файл задачи:
  \begin{minted}{lisp}
   (define (problem example)
     (:domain blocks-world)
     (:objects A B C)
     (:init (on A B) (on B C) (table C) (clear A))
     (:goal (and (on A C))))
  \end{minted}
\end{enumerate}

\newpage

\section{Выбор языка программирования}

Для выполнения данной работы мной был выбран язык программирования Rust~\cite{rust}.
Этот язык имеет много преимуществ по сравнению с другими языками программирования,
как C++, Python, Java или C\#. Наиболее важнымы для качественного выполнения задания являются:

\begin{enumerate}
  \item Высокая производительность:
    \begin{itemize}
      \item Скорость выполнения: Rust компилируется в высокоэффективный машинный код, что обеспечивает производительность, сравнимую с C и C++.
      \item Минимальное время выполнения: В отличие от языков с виртуальной машиной (например, Java), Rust работает без дополнительного слоя абстракции, что снижает накладные расходы.
    \end{itemize}
  \item Безопасность памяти:
    \begin{itemize}
      \item Отсутствие утечек памяти: Rust гарантирует отсутствие утечек памяти за счет своей системы владения и заимствования. Все ресурсы освобождаются автоматически, как только они выходят из области видимости, без необходимости явного управления памятью.
      \item Отсутствие ошибок сегментации: Система заимствования предотвращает множество ошибок, таких как использование уже освобожденной памяти или доступ к данным через некорректные указатели.
      \item Компиляция ошибок памяти: Многие ошибки, связанные с памятью, обнаруживаются на этапе компиляции, что позволяет избежать множества потенциальных багов на этапе выполнения программы.
  \end{itemize}
  \item Параллелизм;
    \begin{itemize}
      \item Безопасный многопоточный код: Rust предоставляет инструменты для безопасного и эффективного написания многопоточного кода. За счет строгой системы владения и заимствования, Rust предотвращает гонки данных на этапе компиляции.
      \item Асинхронное программирование: Встроенная поддержка асинхронного программирования (например, через async/await) позволяет легко и эффективно обрабатывать асинхронные задачи.
    \end{itemize}
  \item Система типов:
  \begin{itemize}
    \item Статическая типизация: Все типы проверяются на этапе компиляции, что позволяет обнаружить множество ошибок до выполнения программы.
    \item Алгебраические типы данных: Rust поддерживает перечисления (enums) и структуры (structs), позволяя определять сложные типы данных и их возможные состояния.
  \end{itemize}
\end{enumerate}

Немаловажным также является тот факт, что из всех упомянутых языков программирования,
я лучше всего знаком с Rust, что только добавляет к уже упомянутым преимуществам.
Но при всех его преимуществах важно понимать также недостатки этого языка:

\begin{enumerate}
  \item Крутая кривая обучения: Понимание концепций владения, заимствования и жизненных циклов требует времени и усилий.
  \item Вербозность
    \begin{itemize}
      \item Жизненные циклы: Иногда требуется явное указание жизненных циклов, что может делать код более многословным и трудным для чтения.
      \item Типажи и обобщенные типы: Использование обобщенных типов и типажей может приводить к увеличению сложности кода и затруднять его чтение.
    \end{itemize}
  \item Жесткость системы типов: Система типов Rust может быть слишком строгой в некоторых случаях, требуя явного указания типов или дополнительных аннотаций там, где другие языки могут быть более гибкими.
\end{enumerate}

Как уже было упомянуто, я знаком с Rust на достаточно хорошем уровне,
поэтому первый пункт их вышеперечисленных слабо применим ко мне,
но вербозность и жесткость системы типов могут быть проблематичными,
особенно при написании данного документа.
Поэтому все примеры кода, присутствующие здесь, не будут соответствовать реальной реализации программы,
они будут упрощены для передачи основной сути программы,
и будут порой игнорировать синтаксические и семантические правила,
чтобы не загромождать пример кода чрезвычайной вербозностью.

\newpage

\section{Выполнение работы}

\subsection{Парсинг PDDL файла}

Первое, что наша программа должна сделать -- это прочесть два файла с описанием домена задачи
и конкретной проблемы в этом домене. Парсинг языка PDDL выходит за рамки этой задачи,
поэтому мы можем взять готовую реализацию в виде библиотеки pddl~\cite{pddl-crate}.
Эта библиотека парсит PDDL версии 3.1 основываясь на документации из Planning.Wiki~\cite{planning-wiki}.
Хотя эта библиотека поддерживает все необходимые элементы спецификации PDDL 3.1,
результаты парсинга очень сильно совпадают с BNF описанием языка из ~\cite{pddl-bnf}. 
Чтобы с ними можно было эффективно работать, нам необходимо преобразовать их в наши собственные типы.

\subsection{Система типов}

\subsubsection{Предикат}

Фундаментальным типом в нашей системе служит предикат:

\begin{minted}{rust}
enum Predicate<T> {
  Equality(Equality<T>),
  Statement(Statement<T>),
  Negated(Predicate<T>),
  True,
  False,
}

struct Equality<T> {
  first: T,
  second: T,
}

struct Statement<T> {
  name: String,
  values: Vec<T>,
}
\end{minted}

Это тип -- перечисление, состоящее из пяти вариантов:
\begin{itemize}
  \item Два простейших -- \texttt{True} и \texttt{False}
  \item Предикат равенства
  \item Предикат общего характера
  \item Предикат отрицания, содержащий в себе какой-либо предикат
\end{itemize}

Может показаться, что предикат равенства можно заменить общим предикатом
с \texttt{name: "Equality"} и массивом их двух элементов,
но равенство -- это фундаментально важная вещь, поэтому ее необходимо обрабатывть отдельно,
а не делать постоянные проверки имени.

\subsubsection{Значения, переменные и константы}

Обобщенный тип \texttt{T} в предикате может заменяться одним их двух типов значения:

\begin{minted}{rust}
enum AmbiguousValue {
  Variable(Variable),
  Constant(Constant),
}

enum GroundedValue {
  Named(Named),
  Constant(Constant),
}

struct Named(String);
struct Variable(String, Type);
struct Constant(String, Type);

enum Type {
  Type(String),
  EitherOf(Vec<Type>),
  Any,
}
\end{minted}

Это нужно, так как предикаты встречаются в разных контекстах:

\begin{itemize}
  \item Как часть цели или условия выражения, где их параметры могут быть либо переменными, либо константами -- то есть потенциально неопределенные
  \item Как часть состояния, где они всегда имеют значение \textit{истина},
    и поэтому их параметры всегда либо константы либо именнованные значения -- то есть определенные
\end{itemize}

\subsubsection{Выражение}

Предикаты могут складываться в выражения, которые используются для описания цели
и для описания условий действий:

\begin{minted}{rust}
enum Expression<T> {
  Predicate(Predicate<T>),
  And(Vec<Expression<T>>),
  Or(Vec<Expression<T>>),
  Not(Expression<T>),
  False,
  True,
}
\end{minted}

Выражения описываются данным типом рекурсивно
и состоять из предикатов и основных логических операций.

Строго говоря \texttt{Expression::False} и \texttt{Expression::True}
не нужны, так как это можно описать используя сами предикаты,
но они упрощают понимание и написание выражений.

\subsubsection{Действия}

Действия могут изменять текущее состояние мира, если их условия выполняются:

\begin{minted}{rust}
struct Action {
  name: String,
  parameters: Vec<Variable>,
  precondition: Expression<AmbiguousValue>,
  effects: Vec<Effect<AmbiguousValue>>,
}
\end{minted}

Структура \texttt{Action} содержит в себе массив переменных \texttt{parameters}.
Он используется для описания параметров действия и связи переменных в условии
с переменными в предикатах эффекта.
В этой структуре мы указываем тип значения для выражений и эффектов явно как \texttt{AmbiguousValue},
потому что действия определяются с переменными.

Несмотря на то, что в PDDL эффекты описываются выражением (которое в нашем случае \texttt{Expression::And}),
состоящим из предикатов без отрицания или с отрицанием в зависимости от того,
нужно ли какой-либо конкретный предикат добавить в состояние или удалить из него,
гораздо проще указать это явно.
\texttt{Effect::MakeTrue} добавляет предикат в состояние,
а \texttt{Effect::MakeFalse} -- убирает.

\begin{minted}{rust}
enum Effect<T> {
  MakeTrue(Predicate<T>),
  MakeFalse(Predicate<T>),
}
\end{minted}

Превратить \texttt{Expression::And} в список из эффектов -- просто,
нужно только не добавлять не \texttt{Predicate::Negated} в \texttt{Expression::MakeFalse},
а его внутренний предикат.

\begin{minted}{rust}
if let Action::And(exprs) = effects {
  exprs.iter().map(|e| match e {
    Negated(pr) => Effect::MakeFalse(pr),
    _ => Effect::MakeTrue(e),
  }).collect()
}
\end{minted}

\subsection{Описание задачи}

Задача, которую наша программа должна решить, описывается следующей структурой:

\begin{minted}{rust}
struct Task {
  name: String,
  initial_state: State,
  goal: Expression<GroundedValue>,
  actions: HashSet<Action>,
}
\end{minted}

Мы храним наше изначальное состояние, цель (как выражение с определенными значениями),
а также набор всех возможных действий.

Само же состояние состоит из набора предикатов, которые верны для данного состояния
(если предикат отстутствует значит он неверен), набора констант, набора именнованных объектов
и всех определенных типов для объектов.

\begin{minted}{rust}
struct State {
  predicates: HashSet<Predicate<GroundedValue>>,
  constants: HashSet<Constant>,
  things: HashSet<Named>,
  types: HashSet<Type>,
}
\end{minted}

\subsection{Изменение состояния действиями}

Чтобы наша программа могла решить задачу планирования, необходимо,
чтобы существовал механизм перехода из одного состояния в другое посредством действий.
Для этого нужно:
\begin{enumerate}
  \item Найти действие, условие которого выполняется
  \item Соотнести его параметры со значениями в состоянии
  \item Применить эффекты действия, используя в них значения из состояния
\end{enumerate}

Эти шаги стоит рассмотреть подробнее.

\subsubsection{Проверка условия действия}

Наши условия состоят из предикатов, содержащих в себе переменные,
а состояние -- из предикатов с конкретными значениями.
Чтобы проверить, выполняется ли конкретное условие,
мы должны:

\begin{enumerate}
  \item Найти все предикаты в состоянии, соответствующие по типу,
    имени и набору значений предикатам в условии действия. Это может выдать несколько предикатов.
  \item Составить копию изначального выражения условия из предикатов,
    полученных на предыдущем шаге (если их было несколько, то для всех возможных комбинаций).
  \item Проверить, выполняются ли эти выражения, путем проверки, находятся ли предикаты выражения в состоянии,
    и комбинации с помощью логических операторов
  \item Если хотя бы одно из выражений является истинным -- значит оно составлено верно и изначальное условие выполняется
\end{enumerate}

\subsubsection{Нахождение соответствующих значений переменным}

Истинные выражения, полученные выше, также используется для сопоставления переменных конкретным значениям в состоянии.
Так как структура выражений идентична структуре условия можно соотнести переменные в предикатах со значениями.

\begin{minted}{rust}
let variable_relations: HashMap<Variable, GroundedValue> =
  flat_precondition
    .iter()
    .zip(flat_grounded_expression.iter())
    .flat_map(|(a, b)| match (a, b) {
      (Equality(eq1), Equality(eq2)) => {
        let mut m = vec![];
        if eq1.first.is_variable_of(eq2.first) {
          m.push(Some((eq1.first, eq2.first)));
        }
        if eq1.second.is_variable_of(eq2.second) {
          m.push(Some((eq1.second, eq2.second)));
        }
        m
      },
      (Statement(st1), Statement(st2)) => {
        st1.values.iter().zip(st2.value).map(|(v1, v2)|
          if v1.is_variable_of(v2) {
            Some((v1, v2))
          } else {
            None
          }
        )
      }
      _ => unreachable!()
    }).flatten().collect();
\end{minted}

На этом шаге также проводится проверка равенства или неравенства переменных друг другу,
информацию о чем можно получить из изначального условия.

\begin{minted}{rust}
let satisfies_equality = equality_constraints
  .iter()
  .all(|c| match (c.first, c.second) {
    (Variable(v1), Variable(v2)) => {
      variable_relations[v1] == variable_relations[v2]
    }
    _ => true,
  });
let satisfies_inequality =
  inequality_constraints
    .iter()
    .all(|c| match (c.first, c.second) {
      (Variable(v1), Variable(v2)) => {
        variable_relations[v1] != variable_relations[v2]
      }
      _ => true,
    });

if satisfies_equality && satisfies_inequality {
  Some(variable_relations)
} else {
  None
}
\end{minted}


\subsubsection{Применение эффектов к состоянию}

Теперь, когда мы знаем отношения между переменными и значениями,
для каждого из предикатов эффекта мы подставляем нужное значение
и применяем его к состоянию.

\begin{minted}{rust}
let mut predicates = self.predicates.clone();
action
  .effects
  .iter()
  .map(|e| e.ground(variable_relations))
  .for_each(|e| match e {
    Effect::MakeTrue(pred) => predicates.insert(pred),
    Effect::MakeFalse(pred) => predicates.remove(pred),
  });

return State {
  predicates,
  constants: self.constants,
  types: self.types,
};
\end{minted}

Результатом является новое состояние, к которому тоже возможно применение действий.

\subsection{Решение задачи}

Решение задачи представляет из себя реализацию алгоритма A*~\cite{astar}.

\begin{enumerate}
  \item Инициализация:
    \begin{enumerate}
      \item Начальное состояние добавляется в очередь открытых состояний с оценкой стоимости пути.
      \item Очередь закрытых состояний инициализируется пустой.
    \end{enumerate}
  \item Поиск:
    \begin{enumerate}
      \item Извлечение состояния с наименьшей оценкой стоимости из очереди открытых состояний.
      \item Если текущее состояние соответствует целевому, завершаем поиск и возвращаем путь действий.
      \item В противном случае, текущее состояние добавляется в закрытый список.
    \end{enumerate}
  \item Развертывание:
    \begin{enumerate}
      \item Для каждого действия проверяются предусловия. Если предусловия выполнены, применяется действие для получения нового состояния.
      \item Для каждого нового состояния вычисляется стоимость пути $g$ и эвристическая оценка $h$, суммируется для получения общей стоимости $f = g + h$.
    \end{enumerate}
  \item Обработка новых состояний:
    \begin{enumerate}
      \item Если новое состояние уже находится в закрытом списке, оно игнорируется.
      \item Если новое состояние не находится в открытом списке или найден более короткий путь к нему, обновляется его информация и добавляется в очередь открытых состояний.
    \end{enumerate}
  \item Повторение: Процесс продолжается до тех пор, пока не будет найдено решение или очередь открытых состояний не станет пустой.
\end{enumerate}

\begin{minted}{rust}
fn a_star(task: &Task) -> Option<Vec<Action>> {
  let mut open_list = BinaryHeap::new();
  let mut closed_list = HashSet::new();

  open_list.push(Node {
    state: task.initial_state.clone(),
    cost: 0,
    estimate: heuristic(&task.initial_state, &task.goal),
    path: vec![],
  });

  while let Some(current_node) = open_list.pop() {
    if is_goal(&current_node.state, &task.goal) {
      return Some(current_node.path);
    }

    closed_list.insert(current_node.state.clone());

    for action in &task.actions {
      if let Some(new_state) = current_node.state.apply(action) {
        if !closed_list.contains(&new_state) {
          let mut new_path = current_node.path.clone();
          new_path.push(action.clone());
          let estimate = heuristic(&new_state, &task.goal)
          open_list.push(Node {
            state: new_state,
            cost: current_node.cost + 1,
            estimate,
            path: new_path,
          });
        }
      }
    }
  }

  None
}
\end{minted}

Здесь мы использовали вспомагательную структуру \texttt{Node},
которая используется для хранения информации о пути до состояния.

\begin{minted}{rust}
struct Node {
  state: State,
  cost: usize,
  estimate: usize,
  path: Vec<Action>,
}
\end{minted}

Если путь был найден успешно, то на выходе из функции мы получим последовательность действий,
которые необходимо применить, чтобы достигнуть желаемого конечного состояния.

\newpage

\section{Дальнейшая работа}

В текущей реализации планировщика использован алгоритм A* для поиска решения задач планирования, описанных в формате PDDL. Несмотря на преимущества Rust в области управления памятью и безопасности, производительность нашего планировщика оставляет желать лучшего. Основной причиной является субоптимальность подхода, связанная с использованием перебора для нахождения соответствующих значений для переменных в действиях.

\subsection{Основные недостатки}

Текущий подход нахождения соответствий между переменными и значениями основывается на переборе всех возможных комбинаций значений для переменных в действиях, что приводит к значительным затратам времени на вычисления. Это особенно критично для задач с большим количеством переменных и возможных значений, где число комбинаций растет экспоненциально.

\subsection{Пути улучшения}

\begin{enumerate}
  \item Улучшение метода поиска значений переменных:
    \begin{itemize}
      \item Умные алгоритмы подбора значений: Использование более умных алгоритмов для подбора значений переменных, таких как алгоритмы CSP (Constraint Satisfaction Problems)~\cite{ghallab2004automated}~\cite{miguel2002csp}, может значительно снизить количество переборов.
      \item Граф планов (Planning Graphs)~\cite{BLUM1997281}: Применение графов планов для нахождения зависимостей между действиями и значениями переменных. Это позволяет сократить пространство поиска, исключив явно невозможные комбинации.
    \end{itemize}
   
\item Оптимизация эвристики:
  \begin{itemize}
    \item Эвристика на основе релаксации (Relaxation-based Heuristics)~\cite{stolba2014relaxation}: Внедрение более сложных эвристических функций, основанных на релаксации проблемы, может существенно улучшить направленность поиска и уменьшить количество исследуемых состояний.
     \item Дополнительные эвристические методы: Использование методов, таких как эвристика hmax или hadd, которые учитывают минимальное количество шагов до достижения цели, может повысить эффективность поиска.
  \end{itemize}

  \item Параллелизация:
    \begin{itemize}
      \item Параллельные алгоритмы поиска: Разработка параллельных версий алгоритма A*, которые используют многопоточность для одновременного исследования нескольких путей, может значительно сократить время поиска.
     \item Асинхронные операции: Использование асинхронных операций и возможностей конкурентного программирования Rust для эффективного управления вычислительными ресурсами.
    \end{itemize}

  \item Улучшение структуры данных:
    \begin{itemize}
      \item Эффективные структуры данных: Применение более эффективных структур данных для хранения и обработки состояний, таких как хеш-таблицы или специализированные графовые структуры, может повысить производительность.
    \end{itemize}

  \item Оптимизация на уровне кода:
    \begin{itemize}
      \item Профилирование и оптимизация: Проведение профилирования кода для выявления узких мест и последующая оптимизация критических участков.
      \item Векторизация и использование SIMD: Использование возможностей SIMD (Single Instruction, Multiple Data) для ускорения вычислений.
    \end{itemize}
\end{enumerate}

\section{Заключение}

В данной работе была представлена реализация планировщика,
использующего язык Rust и основанного на формализме PDDL.
Мы рассмотрели основные аспекты и компоненты планировщиков,
включая начальные состояния, целевые состояния, действия и их предусловия и эффекты.
Также была предоставлена детальная имплементация алгоритма A* для поиска решений задач планирования.

Реализация планировщика на Rust показала хорошие базовые возможности 
и продемонстрировала потенциал для дальнейшего развития.
Применение предложенных улучшений позволит значительно повысить производительность
и применимость планировщика для решения более сложных задач планирования.
В будущей работе мы будем стремиться к реализации этих улучшений
и проведению тестов на сложных и разнообразных задачах,
что позволит оценить эффективность предложенных методов и подходов.

\newpage

\section{Список литературы}
\printbibliography [heading=none]

\end{document}
